// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`loader should work with ts-loader: errors 1`] = `Array []`;

exports[`loader should work with ts-loader: result 1`] = `undefined`;

exports[`loader should work with ts-loader: warnings 1`] = `Array []`;

exports[`loader should work: runner_result 1`] = `
"import Ajv from 'ajv';
import { stringify } from 'query-string';

const ajv = new Ajv();

class ApiError extends Error {
  status: number;

  statusText: string;

  headers: Headers;

  response: any;

  constructor({
    status,
    statusText,
    response,
    message,
    headers,
  }: {
    status: number;
    statusText: string;
    response: any;
    message: string;
    headers: Headers;
  }) {
    super(message);
    this.status = status;
    this.response = response;
    this.statusText = statusText;
    this.headers = headers;
  }
}

class ClientCodeError extends Error {}

class RequestValidationError extends Error {
  element: 'query' | 'params' | 'body' | 'headers';

  method: string;

  errors: any[];

  constructor({
    message,
    element,
    method,
    errors = [],
  }: {
    message: string;
    element: 'query' | 'params' | 'body' | 'headers';
    method: string;
    errors?: any[];
  }) {
    super(message);

    this.element = element;
    this.method = method;
    this.errors = errors;
  }
}

class ResponseValidationError extends Error {
  method: string;

  errors: any[];

  constructor({
    message,
    method,
    errors = [],
  }: {
    message: string;
    method: string;
    errors?: any[];
  }) {
    super(message);

    this.method = method;
    this.errors = errors;
  }
}

export interface Config {
  baseUrl: string;
  preMiddleware: (url: string, params: RequestInit) => Promise<[string, RequestInit]>;
}

const defaultConfig: Config = {
  baseUrl: process.env.API_BASE_URL || '',
  preMiddleware: (url: string, params: RequestInit) => Promise.resolve([url, params]),
};

export interface Category {
  id?: number;
  name?: string;
}

export interface Pet {
  id?: number;
  category?: Category;
  name: string;
  photoUrls: string[];
  tags?: Tag[];
  /**
   * pet status in the store
   */
  status?: 'available' | 'pending' | 'sold';
}

export interface Tag {
  id?: number;
  name?: string;
}

export interface ApiResponse {
  code?: number;
  type?: string;
  message?: string;
}

export interface Order {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: string;
  /**
   * Order Status
   */
  status?: 'placed' | 'approved' | 'delivered';
  complete?: boolean;
}

export interface User {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /**
   * User Status
   */
  userStatus?: number;
}

export type OffsetParamParam = number;

export interface AnotherParamParam {
  dateFrom?: string;
  dateTo?: string;
}

export type ErrorRequestBodyJson = User;

export interface ErrorRequestBodyXml {
  id?: string;
  title?: string;
}

export interface GetPetByIdParams {
  petId: number;
}

export type GetPetByIdResponse = Pet;

export interface UpdatePetWithFormParams {
  petId: number;
}

export interface UpdatePetWithFormRequestBodyXWwwFormUrlencoded {
  /**
   * Updated name of the pet
   */
  name?: string;
  /**
   * Updated status of the pet
   */
  status?: string;
}

export type UpdatePetWithFormResponse = unknown;
export interface DeletePetHeaders {
  api_key?: string;
}

export interface DeletePetParams {
  petId: number;
}

export type DeletePetResponse = unknown;
export interface UploadFileParams {
  petId: number;
}

export interface UploadFileRequestBodyFormData {
  /**
   * Additional data to pass to server
   */
  additionalMetadata?: string;
  /**
   * file to upload
   */
  file?: string;
}

export type UploadFileResponse = ApiResponse;

export type UpdatePetRequestBodyJson = Pet;

export type UpdatePetRequestBodyXml = Pet;

export type UpdatePetResponse = unknown;
export type AddPetRequestBodyJson = Pet;

export type AddPetRequestBodyXml = Pet;

export type AddPetResponse = unknown;
export interface FindPetsByStatusQuery {
  status: ('available' | 'pending' | 'sold')[];
}

export type FindPetsByStatusResponse = Pet[];

export interface FindPetsByTagsQuery {
  tags: string[];
}

export type FindPetsByTagsResponse = Pet[];

export interface GetInventoryResponse {
  [k: string]: number;
}

export interface GetOrderByIdParams {
  orderId: number;
}

export type GetOrderByIdResponse = Order;

export interface DeleteOrderParams {
  orderId: number;
}

export type DeleteOrderResponse = unknown;
export type PlaceOrderRequestBodyJson = Order;

export type PlaceOrderResponse = Order;

export interface GetUserByNameParams {
  username: string;
}

export type GetUserByNameResponse = User;

export interface UpdateUserParams {
  username: string;
}

export type UpdateUserRequestBodyJson = User;

export type UpdateUserResponse = unknown;
export interface DeleteUserParams {
  username: string;
}

export type DeleteUserResponse = unknown;
export interface LoginUserQuery {
  username: string;
  password: string;
}

export type LoginUserResponse = string;

export type LogoutUserResponse = unknown;
export type CreateUserRequestBodyJson = User;

export type CreateUserResponse = unknown;
export type CreateUsersWithArrayInputRequestBodyJson = User[];

export type CreateUsersWithArrayInputResponse = unknown;
export type CreateUsersWithListInputRequestBodyJson = User[];

export type CreateUsersWithListInputResponse = unknown;
export interface GetPetByIdRequest {
  params?: GetPetByIdParams;
}
export const getPetById: (
  request: GetPetByIdRequest,
  config: Config
) => Promise<GetPetByIdResponse> = async ({ params = {} } = {}, config = defaultConfig) => {
  let requestUrl = \`\${config.baseUrl}/pet/{petId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
  };

  function isParams(obj: unknown): obj is GetPetByIdParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'getPetById',
      element: 'params',
    });
  }

  type GetPetByIdParamsKeys = keyof GetPetByIdParams;

  const paramsKeys = Object.keys(params) as GetPetByIdParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching getPetById',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  const responseSchema = {
    required: ['name', 'photoUrls'],
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      category: {
        type: 'object',
        properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
        xml: { name: 'Category' },
      },
      name: { type: 'string', example: 'doggie' },
      photoUrls: {
        type: 'array',
        xml: { wrapped: true },
        items: { type: 'string', xml: { name: 'photoUrl' } },
      },
      tags: {
        type: 'array',
        xml: { wrapped: true },
        items: {
          type: 'object',
          properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
          xml: { name: 'Tag' },
        },
      },
      status: {
        type: 'string',
        description: 'pet status in the store',
        enum: ['available', 'pending', 'sold'],
      },
    },
    xml: { name: 'Pet' },
  };

  function isResponse(obj: unknown): obj is GetPetByIdResponse {
    const isValid = ajv.validate(responseSchema, obj);

    return !!isValid;
  }

  if (!isResponse(response)) {
    throw new ResponseValidationError({
      message: 'Response schema validation error',
      method: 'getPetById',
    });
  }

  return response;
};
export interface UpdatePetWithFormRequest {
  params?: UpdatePetWithFormParams;
  data?: UpdatePetWithFormRequestBodyXWwwFormUrlencoded;
}
export const updatePetWithForm: (
  request: UpdatePetWithFormRequest,
  config: Config
) => Promise<UpdatePetWithFormResponse> = async (
  { params = {}, data = {} } = {},
  config = defaultConfig
) => {
  let requestUrl = \`\${config.baseUrl}/pet/{petId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
  };

  function isParams(obj: unknown): obj is UpdatePetWithFormParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'updatePetWithForm',
      element: 'params',
    });
  }

  type UpdatePetWithFormParamsKeys = keyof UpdatePetWithFormParams;

  const paramsKeys = Object.keys(params) as UpdatePetWithFormParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/x-www-form-urlencoded',
  };

  const bodySchema = {
    properties: {
      name: { type: 'string', description: 'Updated name of the pet' },
      status: { type: 'string', description: 'Updated status of the pet' },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'updatePetWithForm',
      element: 'body',
    });
  }

  let requestParams;

  if (data) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body: data instanceof FormData ? data : JSON.stringify(data),
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching updatePetWithForm',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as UpdatePetWithFormResponse;
};
export interface DeletePetRequest {
  params?: DeletePetParams;
  headers?: DeletePetHeaders;
}
export const deletePet: (
  request: DeletePetRequest,
  config: Config
) => Promise<DeletePetResponse> = async (
  { params = {}, headers = {} } = {},
  config = defaultConfig
) => {
  let requestUrl = \`\${config.baseUrl}/pet/{petId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
  };

  function isParams(obj: unknown): obj is DeletePetParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'deletePet',
      element: 'params',
    });
  }

  type DeletePetParamsKeys = keyof DeletePetParams;

  const paramsKeys = Object.keys(params) as DeletePetParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const headersSchema = {
    type: 'object',
    required: [],
    properties: { api_key: { type: 'string' } },
  };

  function isHeaders(obj: unknown): obj is DeletePetHeaders {
    const isValid = ajv.validate(headersSchema, obj);

    return !!isValid;
  }

  if (!isHeaders(headers)) {
    throw new RequestValidationError({
      message: 'Request headers schema validation error',
      method: 'deletePet',
      element: 'headers',
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
    ...headers,
  };

  const requestParams = {
    method: 'DELETE',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(
      requestUrl,
      requestParams as RequestInit
    );
    const responseObject = await fetch(processedUrl, processedParams as RequestInit);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching deletePet',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as DeletePetResponse;
};
export interface UploadFileRequest {
  params?: UploadFileParams;
  data?: UploadFileRequestBodyFormData;
}
export const uploadFile: (
  request: UploadFileRequest,
  config: Config
) => Promise<UploadFileResponse> = async (
  { params = {}, data = {} } = {},
  config = defaultConfig
) => {
  let requestUrl = \`\${config.baseUrl}/pet/{petId}/uploadImage\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
  };

  function isParams(obj: unknown): obj is UploadFileParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'uploadFile',
      element: 'params',
    });
  }

  type UploadFileParamsKeys = keyof UploadFileParams;

  const paramsKeys = Object.keys(params) as UploadFileParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'multipart/form-data',
  };

  const bodySchema = {
    properties: {
      additionalMetadata: { type: 'string', description: 'Additional data to pass to server' },
      file: { type: 'string', description: 'file to upload', format: 'binary' },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'uploadFile',
      element: 'body',
    });
  }

  let requestParams;

  if (data) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body: data instanceof FormData ? data : JSON.stringify(data),
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching uploadFile',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  const responseSchema = {
    type: 'object',
    properties: {
      code: { type: 'integer', format: 'int32' },
      type: { type: 'string' },
      message: { type: 'string' },
    },
  };

  function isResponse(obj: unknown): obj is UploadFileResponse {
    const isValid = ajv.validate(responseSchema, obj);

    return !!isValid;
  }

  if (!isResponse(response)) {
    throw new ResponseValidationError({
      message: 'Response schema validation error',
      method: 'uploadFile',
    });
  }

  return response;
};
export interface UpdatePetRequest {
  data?: UpdatePetRequestBodyXml;
}
export const updatePet: (
  request: UpdatePetRequest,
  config: Config
) => Promise<UpdatePetResponse> = async ({ data = {} } = {}, config = defaultConfig) => {
  const requestUrl = \`\${config.baseUrl}/pet\`;

  const requestHeaders = {
    'Content-Type': 'application/xml',
  };

  const bodySchema = {
    required: ['name', 'photoUrls'],
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      category: {
        type: 'object',
        properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
        xml: { name: 'Category' },
      },
      name: { type: 'string', example: 'doggie' },
      photoUrls: {
        type: 'array',
        xml: { wrapped: true },
        items: { type: 'string', xml: { name: 'photoUrl' } },
      },
      tags: {
        type: 'array',
        xml: { wrapped: true },
        items: {
          type: 'object',
          properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
          xml: { name: 'Tag' },
        },
      },
      status: {
        type: 'string',
        description: 'pet status in the store',
        enum: ['available', 'pending', 'sold'],
      },
    },
    xml: { name: 'Pet' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'updatePet',
      element: 'body',
    });
  }

  let requestParams;

  if (data) {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
      body: data instanceof FormData ? data : JSON.stringify(data),
    };
  } else {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
    };
  }

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching updatePet',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as UpdatePetResponse;
};
export interface AddPetRequest {
  data?: AddPetRequestBodyXml;
}
export const addPet: (request: AddPetRequest, config: Config) => Promise<AddPetResponse> = async (
  { data = {} } = {},
  config = defaultConfig
) => {
  const requestUrl = \`\${config.baseUrl}/pet\`;

  const requestHeaders = {
    'Content-Type': 'application/xml',
  };

  const bodySchema = {
    required: ['name', 'photoUrls'],
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      category: {
        type: 'object',
        properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
        xml: { name: 'Category' },
      },
      name: { type: 'string', example: 'doggie' },
      photoUrls: {
        type: 'array',
        xml: { wrapped: true },
        items: { type: 'string', xml: { name: 'photoUrl' } },
      },
      tags: {
        type: 'array',
        xml: { wrapped: true },
        items: {
          type: 'object',
          properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
          xml: { name: 'Tag' },
        },
      },
      status: {
        type: 'string',
        description: 'pet status in the store',
        enum: ['available', 'pending', 'sold'],
      },
    },
    xml: { name: 'Pet' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'addPet',
      element: 'body',
    });
  }

  let requestParams;

  if (data) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body: data instanceof FormData ? data : JSON.stringify(data),
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching addPet',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as AddPetResponse;
};
export interface FindPetsByStatusRequest {
  query?: FindPetsByStatusQuery;
}
export const findPetsByStatus: (
  request: FindPetsByStatusRequest,
  config: Config
) => Promise<FindPetsByStatusResponse> = async ({ query = {} } = {}, config = defaultConfig) => {
  let requestUrl = \`\${config.baseUrl}/pet/findByStatus\`;

  const querySchema = {
    type: 'object',
    required: ['status'],
    properties: {
      status: {
        type: 'array',
        items: { type: 'string', default: 'available', enum: ['available', 'pending', 'sold'] },
      },
    },
  };

  function isQuery(obj: unknown): obj is FindPetsByStatusQuery {
    const isValid = ajv.validate(querySchema, obj);

    return !!isValid;
  }

  if (!isQuery(query)) {
    throw new RequestValidationError({
      message: 'Request query string schema validation error',
      method: 'findPetsByStatus',
      element: 'query',
    });
  }

  if (Object.keys(query)) {
    requestUrl = \`\${requestUrl}?\${stringify(query, { arrayFormat: 'bracket' })}\`;
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching findPetsByStatus',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  const responseSchema = {
    type: 'array',
    items: {
      required: ['name', 'photoUrls'],
      type: 'object',
      properties: {
        id: { type: 'integer', format: 'int64' },
        category: {
          type: 'object',
          properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
          xml: { name: 'Category' },
        },
        name: { type: 'string', example: 'doggie' },
        photoUrls: {
          type: 'array',
          xml: { wrapped: true },
          items: { type: 'string', xml: { name: 'photoUrl' } },
        },
        tags: {
          type: 'array',
          xml: { wrapped: true },
          items: {
            type: 'object',
            properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
            xml: { name: 'Tag' },
          },
        },
        status: {
          type: 'string',
          description: 'pet status in the store',
          enum: ['available', 'pending', 'sold'],
        },
      },
      xml: { name: 'Pet' },
    },
  };

  function isResponse(obj: unknown): obj is FindPetsByStatusResponse {
    const isValid = ajv.validate(responseSchema, obj);

    return !!isValid;
  }

  if (!isResponse(response)) {
    throw new ResponseValidationError({
      message: 'Response schema validation error',
      method: 'findPetsByStatus',
    });
  }

  return response;
};
export interface FindPetsByTagsRequest {
  query?: FindPetsByTagsQuery;
}
export const findPetsByTags: (
  request: FindPetsByTagsRequest,
  config: Config
) => Promise<FindPetsByTagsResponse> = async ({ query = {} } = {}, config = defaultConfig) => {
  let requestUrl = \`\${config.baseUrl}/pet/findByTags\`;

  const querySchema = {
    type: 'object',
    required: ['tags'],
    properties: { tags: { type: 'array', items: { type: 'string' } } },
  };

  function isQuery(obj: unknown): obj is FindPetsByTagsQuery {
    const isValid = ajv.validate(querySchema, obj);

    return !!isValid;
  }

  if (!isQuery(query)) {
    throw new RequestValidationError({
      message: 'Request query string schema validation error',
      method: 'findPetsByTags',
      element: 'query',
    });
  }

  if (Object.keys(query)) {
    requestUrl = \`\${requestUrl}?\${stringify(query, { arrayFormat: 'bracket' })}\`;
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching findPetsByTags',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  const responseSchema = {
    type: 'array',
    items: {
      required: ['name', 'photoUrls'],
      type: 'object',
      properties: {
        id: { type: 'integer', format: 'int64' },
        category: {
          type: 'object',
          properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
          xml: { name: 'Category' },
        },
        name: { type: 'string', example: 'doggie' },
        photoUrls: {
          type: 'array',
          xml: { wrapped: true },
          items: { type: 'string', xml: { name: 'photoUrl' } },
        },
        tags: {
          type: 'array',
          xml: { wrapped: true },
          items: {
            type: 'object',
            properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
            xml: { name: 'Tag' },
          },
        },
        status: {
          type: 'string',
          description: 'pet status in the store',
          enum: ['available', 'pending', 'sold'],
        },
      },
      xml: { name: 'Pet' },
    },
  };

  function isResponse(obj: unknown): obj is FindPetsByTagsResponse {
    const isValid = ajv.validate(responseSchema, obj);

    return !!isValid;
  }

  if (!isResponse(response)) {
    throw new ResponseValidationError({
      message: 'Response schema validation error',
      method: 'findPetsByTags',
    });
  }

  return response;
};
export const getInventory: (config: Config) => Promise<GetInventoryResponse> = async (
  config = defaultConfig
) => {
  const requestUrl = \`\${config.baseUrl}/store/inventory\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching getInventory',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  const responseSchema = {
    type: 'object',
    additionalProperties: { type: 'integer', format: 'int32' },
  };

  function isResponse(obj: unknown): obj is GetInventoryResponse {
    const isValid = ajv.validate(responseSchema, obj);

    return !!isValid;
  }

  if (!isResponse(response)) {
    throw new ResponseValidationError({
      message: 'Response schema validation error',
      method: 'getInventory',
    });
  }

  return response;
};
export interface GetOrderByIdRequest {
  params?: GetOrderByIdParams;
}
export const getOrderById: (
  request: GetOrderByIdRequest,
  config: Config
) => Promise<GetOrderByIdResponse> = async ({ params = {} } = {}, config = defaultConfig) => {
  let requestUrl = \`\${config.baseUrl}/store/order/{orderId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['orderId'],
    properties: { orderId: { maximum: 10, minimum: 1, type: 'integer', format: 'int64' } },
  };

  function isParams(obj: unknown): obj is GetOrderByIdParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'getOrderById',
      element: 'params',
    });
  }

  type GetOrderByIdParamsKeys = keyof GetOrderByIdParams;

  const paramsKeys = Object.keys(params) as GetOrderByIdParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching getOrderById',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  const responseSchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      petId: { type: 'integer', format: 'int64' },
      quantity: { type: 'integer', format: 'int32' },
      shipDate: { type: 'string', format: 'date-time' },
      status: {
        type: 'string',
        description: 'Order Status',
        enum: ['placed', 'approved', 'delivered'],
      },
      complete: { type: 'boolean' },
    },
    xml: { name: 'Order' },
  };

  function isResponse(obj: unknown): obj is GetOrderByIdResponse {
    const isValid = ajv.validate(responseSchema, obj);

    return !!isValid;
  }

  if (!isResponse(response)) {
    throw new ResponseValidationError({
      message: 'Response schema validation error',
      method: 'getOrderById',
    });
  }

  return response;
};
export interface DeleteOrderRequest {
  params?: DeleteOrderParams;
}
export const deleteOrder: (
  request: DeleteOrderRequest,
  config: Config
) => Promise<DeleteOrderResponse> = async ({ params = {} } = {}, config = defaultConfig) => {
  let requestUrl = \`\${config.baseUrl}/store/order/{orderId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['orderId'],
    properties: { orderId: { minimum: 1, type: 'integer', format: 'int64' } },
  };

  function isParams(obj: unknown): obj is DeleteOrderParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'deleteOrder',
      element: 'params',
    });
  }

  type DeleteOrderParamsKeys = keyof DeleteOrderParams;

  const paramsKeys = Object.keys(params) as DeleteOrderParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'DELETE',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching deleteOrder',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as DeleteOrderResponse;
};
export interface PlaceOrderRequest {
  data?: PlaceOrderRequestBodyJson;
}
export const placeOrder: (
  request: PlaceOrderRequest,
  config: Config
) => Promise<PlaceOrderResponse> = async ({ data = {} } = {}, config = defaultConfig) => {
  const requestUrl = \`\${config.baseUrl}/store/order\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      petId: { type: 'integer', format: 'int64' },
      quantity: { type: 'integer', format: 'int32' },
      shipDate: { type: 'string', format: 'date-time' },
      status: {
        type: 'string',
        description: 'Order Status',
        enum: ['placed', 'approved', 'delivered'],
      },
      complete: { type: 'boolean' },
    },
    xml: { name: 'Order' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'placeOrder',
      element: 'body',
    });
  }

  let requestParams;

  if (data) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body: data instanceof FormData ? data : JSON.stringify(data),
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching placeOrder',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  const responseSchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      petId: { type: 'integer', format: 'int64' },
      quantity: { type: 'integer', format: 'int32' },
      shipDate: { type: 'string', format: 'date-time' },
      status: {
        type: 'string',
        description: 'Order Status',
        enum: ['placed', 'approved', 'delivered'],
      },
      complete: { type: 'boolean' },
    },
    xml: { name: 'Order' },
  };

  function isResponse(obj: unknown): obj is PlaceOrderResponse {
    const isValid = ajv.validate(responseSchema, obj);

    return !!isValid;
  }

  if (!isResponse(response)) {
    throw new ResponseValidationError({
      message: 'Response schema validation error',
      method: 'placeOrder',
    });
  }

  return response;
};
export interface GetUserByNameRequest {
  params?: GetUserByNameParams;
}
export const getUserByName: (
  request: GetUserByNameRequest,
  config: Config
) => Promise<GetUserByNameResponse> = async ({ params = {} } = {}, config = defaultConfig) => {
  let requestUrl = \`\${config.baseUrl}/user/{username}\`;

  const paramsSchema = {
    type: 'object',
    required: ['username'],
    properties: { username: { type: 'string' } },
  };

  function isParams(obj: unknown): obj is GetUserByNameParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'getUserByName',
      element: 'params',
    });
  }

  type GetUserByNameParamsKeys = keyof GetUserByNameParams;

  const paramsKeys = Object.keys(params) as GetUserByNameParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching getUserByName',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  const responseSchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      username: { type: 'string' },
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      password: { type: 'string' },
      phone: { type: 'string' },
      userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
    },
    xml: { name: 'User' },
  };

  function isResponse(obj: unknown): obj is GetUserByNameResponse {
    const isValid = ajv.validate(responseSchema, obj);

    return !!isValid;
  }

  if (!isResponse(response)) {
    throw new ResponseValidationError({
      message: 'Response schema validation error',
      method: 'getUserByName',
    });
  }

  return response;
};
export interface UpdateUserRequest {
  params?: UpdateUserParams;
  data?: UpdateUserRequestBodyJson;
}
export const updateUser: (
  request: UpdateUserRequest,
  config: Config
) => Promise<UpdateUserResponse> = async (
  { params = {}, data = {} } = {},
  config = defaultConfig
) => {
  let requestUrl = \`\${config.baseUrl}/user/{username}\`;

  const paramsSchema = {
    type: 'object',
    required: ['username'],
    properties: { username: { type: 'string' } },
  };

  function isParams(obj: unknown): obj is UpdateUserParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'updateUser',
      element: 'params',
    });
  }

  type UpdateUserParamsKeys = keyof UpdateUserParams;

  const paramsKeys = Object.keys(params) as UpdateUserParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      username: { type: 'string' },
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      password: { type: 'string' },
      phone: { type: 'string' },
      userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
    },
    xml: { name: 'User' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'updateUser',
      element: 'body',
    });
  }

  let requestParams;

  if (data) {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
      body: data instanceof FormData ? data : JSON.stringify(data),
    };
  } else {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
    };
  }

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching updateUser',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as UpdateUserResponse;
};
export interface DeleteUserRequest {
  params?: DeleteUserParams;
}
export const deleteUser: (
  request: DeleteUserRequest,
  config: Config
) => Promise<DeleteUserResponse> = async ({ params = {} } = {}, config = defaultConfig) => {
  let requestUrl = \`\${config.baseUrl}/user/{username}\`;

  const paramsSchema = {
    type: 'object',
    required: ['username'],
    properties: { username: { type: 'string' } },
  };

  function isParams(obj: unknown): obj is DeleteUserParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'deleteUser',
      element: 'params',
    });
  }

  type DeleteUserParamsKeys = keyof DeleteUserParams;

  const paramsKeys = Object.keys(params) as DeleteUserParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'DELETE',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching deleteUser',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as DeleteUserResponse;
};
export interface LoginUserRequest {
  query?: LoginUserQuery;
}
export const loginUser: (
  request: LoginUserRequest,
  config: Config
) => Promise<LoginUserResponse> = async ({ query = {} } = {}, config = defaultConfig) => {
  let requestUrl = \`\${config.baseUrl}/user/login\`;

  const querySchema = {
    type: 'object',
    required: ['username', 'password'],
    properties: { username: { type: 'string' }, password: { type: 'string' } },
  };

  function isQuery(obj: unknown): obj is LoginUserQuery {
    const isValid = ajv.validate(querySchema, obj);

    return !!isValid;
  }

  if (!isQuery(query)) {
    throw new RequestValidationError({
      message: 'Request query string schema validation error',
      method: 'loginUser',
      element: 'query',
    });
  }

  if (Object.keys(query)) {
    requestUrl = \`\${requestUrl}?\${stringify(query, { arrayFormat: 'bracket' })}\`;
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching loginUser',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  const responseSchema = { type: 'string' };

  function isResponse(obj: unknown): obj is LoginUserResponse {
    const isValid = ajv.validate(responseSchema, obj);

    return !!isValid;
  }

  if (!isResponse(response)) {
    throw new ResponseValidationError({
      message: 'Response schema validation error',
      method: 'loginUser',
    });
  }

  return response;
};
export const logoutUser: (config: Config) => Promise<LogoutUserResponse> = async (
  config = defaultConfig
) => {
  const requestUrl = \`\${config.baseUrl}/user/logout\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching logoutUser',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as LogoutUserResponse;
};
export interface CreateUserRequest {
  data?: CreateUserRequestBodyJson;
}
export const createUser: (
  request: CreateUserRequest,
  config: Config
) => Promise<CreateUserResponse> = async ({ data = {} } = {}, config = defaultConfig) => {
  const requestUrl = \`\${config.baseUrl}/user\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      username: { type: 'string' },
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      password: { type: 'string' },
      phone: { type: 'string' },
      userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
    },
    xml: { name: 'User' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'createUser',
      element: 'body',
    });
  }

  let requestParams;

  if (data) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body: data instanceof FormData ? data : JSON.stringify(data),
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching createUser',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as CreateUserResponse;
};
export interface CreateUsersWithArrayInputRequest {
  data?: CreateUsersWithArrayInputRequestBodyJson;
}
export const createUsersWithArrayInput: (
  request: CreateUsersWithArrayInputRequest,
  config: Config
) => Promise<CreateUsersWithArrayInputResponse> = async (
  { data = {} } = {},
  config = defaultConfig
) => {
  const requestUrl = \`\${config.baseUrl}/user/createWithArray\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'array',
    items: {
      type: 'object',
      properties: {
        id: { type: 'integer', format: 'int64' },
        username: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        email: { type: 'string' },
        password: { type: 'string' },
        phone: { type: 'string' },
        userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
      },
      xml: { name: 'User' },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'createUsersWithArrayInput',
      element: 'body',
    });
  }

  let requestParams;

  if (data) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body: data instanceof FormData ? data : JSON.stringify(data),
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching createUsersWithArrayInput',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as CreateUsersWithArrayInputResponse;
};
export interface CreateUsersWithListInputRequest {
  data?: CreateUsersWithListInputRequestBodyJson;
}
export const createUsersWithListInput: (
  request: CreateUsersWithListInputRequest,
  config: Config
) => Promise<CreateUsersWithListInputResponse> = async (
  { data = {} } = {},
  config = defaultConfig
) => {
  const requestUrl = \`\${config.baseUrl}/user/createWithList\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'array',
    items: {
      type: 'object',
      properties: {
        id: { type: 'integer', format: 'int64' },
        username: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        email: { type: 'string' },
        password: { type: 'string' },
        phone: { type: 'string' },
        userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
      },
      xml: { name: 'User' },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'createUsersWithListInput',
      element: 'body',
    });
  }

  let requestParams;

  if (data) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body: data instanceof FormData ? data : JSON.stringify(data),
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  let response: unknown;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    const responseObject = await fetch(processedUrl, processedParams);
    response = await responseObject.json();

    if (!responseObject.ok) {
      throw new ApiError({
        message: 'Api error while fetching createUsersWithListInput',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response,
        headers: responseObject.headers,
      });
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  return response as CreateUsersWithListInputResponse;
};
"
`;
