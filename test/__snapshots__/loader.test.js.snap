// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`loader should work with babel-loader: errors 1`] = `Array []`;

exports[`loader should work with babel-loader: result 1`] = `undefined`;

exports[`loader should work with babel-loader: warnings 1`] = `Array []`;

exports[`loader should work with js compiler: runner_result_js 1`] = `
"import Ajv from 'ajv';
import { stringify } from 'query-string';
import objectToFormData from 'object-to-formdata';

const ajv = new Ajv({ unknownFormats: ['int32', 'int64', 'binary'] });

export class ApiError extends Error {
  constructor({ status, statusText, response, message, headers }) {
    super(message);
    this.status = status;
    this.response = response;
    this.statusText = statusText;
    this.headers = headers;
  }
}

export class ClientCodeError extends Error {}

export class RequestValidationError extends Error {
  constructor({ message, element, method, errors = [] }) {
    super(message);

    this.element = element;
    this.method = method;
    this.errors = errors;
  }
}

export class ResponseValidationError extends Error {
  constructor({ message, method, errors = [] }) {
    super(message);

    this.method = method;
    this.errors = errors;
  }
}

const defaultConfig = {
  baseUrl: process.env.API_BASE_URL || 'https://petstore.swagger.io/v2',
  preMiddleware: (url, params) => Promise.resolve([url, params]),
};

function jsToUrlEncoded(element, key = '', list = []) {
  const components = list;

  if (typeof element === 'object') {
    for (let idx in element) {
      jsToUrlEncoded(element[idx], key ? \`\${key}[\${idx}]\` : idx, components);
    }
  } else {
    components.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(element)}\`);
  }

  return components.join('&');
}

export const someOperation = async ({ data = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/pet/someOperation\`;

  const requestHeaders = {
    'Content-Type': 'application/x-www-form-urlencoded',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      name: { type: 'string', description: 'Name' },
      meta: {
        type: 'object',
        description: 'meta information',
        properties: { title: { type: 'string' }, length: { type: 'number' } },
      },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'someOperation',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = jsToUrlEncoded(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching someOperation',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '200': {
      response: {
        type: 'object',
        properties: {
          code: { type: 'integer', format: 'int32' },
          type: { type: 'string' },
          message: { type: 'string' },
        },
      },
      contentTypes: ['application/json'],
    },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'someOperation',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const getPetById = async ({ params = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/{petId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj) {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'getPetById',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  const paramsKeys = Object.keys(params);

  if (paramsKeys.length) {
    paramsKeys.forEach((param) => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching getPetById',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '200': {
      response: {
        required: ['name', 'photoUrls'],
        type: 'object',
        properties: {
          id: { type: 'integer', format: 'int64' },
          category: {
            type: 'object',
            properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
            xml: { name: 'Category' },
          },
          name: { type: 'string', example: 'doggie' },
          photoUrls: {
            type: 'array',
            xml: { wrapped: true },
            items: { type: 'string', xml: { name: 'photoUrl' } },
          },
          tags: {
            type: 'array',
            xml: { wrapped: true },
            items: {
              type: 'object',
              properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
              xml: { name: 'Tag' },
            },
          },
          status: {
            type: 'string',
            description: 'pet status in the store',
            enum: ['available', 'pending', 'sold'],
          },
        },
        xml: { name: 'Pet' },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'getPetById',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const updatePetWithForm = async (
  { params = {}, data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/{petId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj) {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'updatePetWithForm',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  const paramsKeys = Object.keys(params);

  if (paramsKeys.length) {
    paramsKeys.forEach((param) => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      username: { type: 'string' },
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      password: { type: 'string' },
      phone: { type: 'string' },
      userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
    },
    xml: { name: 'User' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'updatePetWithForm',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching updatePetWithForm',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = { '405': { response: null, contentTypes: null } };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'updatePetWithForm',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const deletePet = async (
  { params = {}, headers = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/{petId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj) {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'deletePet',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  const paramsKeys = Object.keys(params);

  if (paramsKeys.length) {
    paramsKeys.forEach((param) => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const headersSchema = {
    type: 'object',
    required: [],
    properties: { api_key: { type: 'string' } },
    additionalProperties: false,
  };

  function isHeaders(obj) {
    const isValid = ajv.validate(headersSchema, obj);

    return !!isValid;
  }

  if (!isHeaders(headers)) {
    throw new RequestValidationError({
      message: 'Request headers schema validation error',
      method: 'deletePet',
      element: 'headers',
      errors: ajv.errors || [],
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
    ...headers,
  };

  const requestParams = {
    method: 'DELETE',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching deletePet',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'deletePet',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const uploadFile = async (
  { params = {}, data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/{petId}/uploadImage\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj) {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'uploadFile',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  const paramsKeys = Object.keys(params);

  if (paramsKeys.length) {
    paramsKeys.forEach((param) => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'multipart/form-data',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      additionalMetadata: { type: 'string', description: 'Additional data to pass to server' },
      file: { type: 'object', description: 'file to upload', format: 'binary' },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'uploadFile',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = objectToFormData(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching uploadFile',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '200': {
      response: {
        type: 'object',
        properties: {
          code: { type: 'integer', format: 'int32' },
          type: { type: 'string' },
          message: { type: 'string' },
        },
      },
      contentTypes: ['application/json'],
    },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'uploadFile',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const updatePet = async ({ data = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/pet\`;

  const requestHeaders = {
    'Content-Type': 'application/json; charset=utf-8',
  };

  const bodySchema = {
    required: ['name', 'photoUrls'],
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      category: {
        type: 'object',
        properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
        xml: { name: 'Category' },
      },
      name: { type: 'string', example: 'doggie' },
      photoUrls: {
        type: 'array',
        xml: { wrapped: true },
        items: { type: 'string', xml: { name: 'photoUrl' } },
      },
      tags: {
        type: 'array',
        xml: { wrapped: true },
        items: {
          type: 'object',
          properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
          xml: { name: 'Tag' },
        },
      },
      status: {
        type: 'string',
        description: 'pet status in the store',
        enum: ['available', 'pending', 'sold'],
      },
    },
    xml: { name: 'Pet' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'updatePet',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
    };
  }

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching updatePet',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
    '405': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'updatePet',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const addPet = async ({ data = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/pet\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    required: ['name', 'photoUrls'],
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      category: {
        type: 'object',
        properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
        xml: { name: 'Category' },
      },
      name: { type: 'string', example: 'doggie' },
      photoUrls: {
        type: 'array',
        xml: { wrapped: true },
        items: { type: 'string', xml: { name: 'photoUrl' } },
      },
      tags: {
        type: 'array',
        xml: { wrapped: true },
        items: {
          type: 'object',
          properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
          xml: { name: 'Tag' },
        },
      },
      status: {
        type: 'string',
        description: 'pet status in the store',
        enum: ['available', 'pending', 'sold'],
      },
    },
    xml: { name: 'Pet' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'addPet',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching addPet',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = { '405': { response: null, contentTypes: null } };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'addPet',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const findPetsByStatus = async ({ query = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/findByStatus\`;

  const querySchema = {
    type: 'object',
    required: ['status'],
    properties: {
      status: {
        type: 'array',
        items: { type: 'string', default: 'available', enum: ['available', 'pending', 'sold'] },
      },
    },
    additionalProperties: false,
  };

  function isQuery(obj) {
    const isValid = ajv.validate(querySchema, obj);

    return !!isValid;
  }

  if (!isQuery(query)) {
    throw new RequestValidationError({
      message: 'Request query string schema validation error',
      method: 'findPetsByStatus',
      element: 'query',
      errors: ajv.errors || [],
    });
  }

  if (Object.keys(query)) {
    requestUrl = \`\${requestUrl}?\${stringify(query, { arrayFormat: 'bracket' })}\`;
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching findPetsByStatus',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '200': {
      response: {
        type: 'array',
        items: {
          required: ['name', 'photoUrls'],
          type: 'object',
          properties: {
            id: { type: 'integer', format: 'int64' },
            category: {
              type: 'object',
              properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
              xml: { name: 'Category' },
            },
            name: { type: 'string', example: 'doggie' },
            photoUrls: {
              type: 'array',
              xml: { wrapped: true },
              items: { type: 'string', xml: { name: 'photoUrl' } },
            },
            tags: {
              type: 'array',
              xml: { wrapped: true },
              items: {
                type: 'object',
                properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
                xml: { name: 'Tag' },
              },
            },
            status: {
              type: 'string',
              description: 'pet status in the store',
              enum: ['available', 'pending', 'sold'],
            },
          },
          xml: { name: 'Pet' },
        },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'findPetsByStatus',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const findPetsByTags = async ({ query = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/findByTags\`;

  const querySchema = {
    type: 'object',
    required: ['tags'],
    properties: { tags: { type: 'array', items: { type: 'string' } } },
    additionalProperties: false,
  };

  function isQuery(obj) {
    const isValid = ajv.validate(querySchema, obj);

    return !!isValid;
  }

  if (!isQuery(query)) {
    throw new RequestValidationError({
      message: 'Request query string schema validation error',
      method: 'findPetsByTags',
      element: 'query',
      errors: ajv.errors || [],
    });
  }

  if (Object.keys(query)) {
    requestUrl = \`\${requestUrl}?\${stringify(query, { arrayFormat: 'bracket' })}\`;
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching findPetsByTags',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '200': {
      response: {
        type: 'array',
        items: {
          required: ['name', 'photoUrls'],
          type: 'object',
          properties: {
            id: { type: 'integer', format: 'int64' },
            category: {
              type: 'object',
              properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
              xml: { name: 'Category' },
            },
            name: { type: 'string', example: 'doggie' },
            photoUrls: {
              type: 'array',
              xml: { wrapped: true },
              items: { type: 'string', xml: { name: 'photoUrl' } },
            },
            tags: {
              type: 'array',
              xml: { wrapped: true },
              items: {
                type: 'object',
                properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
                xml: { name: 'Tag' },
              },
            },
            status: {
              type: 'string',
              description: 'pet status in the store',
              enum: ['available', 'pending', 'sold'],
            },
          },
          xml: { name: 'Pet' },
        },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'findPetsByTags',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const getInventory = async (currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/store/inventory\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching getInventory',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '200': {
      response: { type: 'object', additionalProperties: { type: 'integer', format: 'int32' } },
      contentTypes: ['application/json'],
    },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'getInventory',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const getOrderById = async ({ params = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/store/order/{orderId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['orderId'],
    properties: { orderId: { maximum: 10, minimum: 1, type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj) {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'getOrderById',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  const paramsKeys = Object.keys(params);

  if (paramsKeys.length) {
    paramsKeys.forEach((param) => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching getOrderById',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '200': {
      response: {
        type: 'object',
        properties: {
          id: { type: 'integer', format: 'int64' },
          petId: { type: 'integer', format: 'int64' },
          quantity: { type: 'integer', format: 'int32' },
          shipDate: { type: 'string', format: 'date-time' },
          status: {
            type: 'string',
            description: 'Order Status',
            enum: ['placed', 'approved', 'delivered'],
          },
          complete: { type: 'boolean' },
        },
        xml: { name: 'Order' },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'getOrderById',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const deleteOrder = async ({ params = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/store/order/{orderId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['orderId'],
    properties: { orderId: { minimum: 1, type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj) {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'deleteOrder',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  const paramsKeys = Object.keys(params);

  if (paramsKeys.length) {
    paramsKeys.forEach((param) => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'DELETE',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching deleteOrder',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'deleteOrder',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const placeOrder = async ({ data = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/store/order\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      petId: { type: 'integer', format: 'int64' },
      quantity: { type: 'integer', format: 'int32' },
      shipDate: { type: 'string', format: 'date-time' },
      status: {
        type: 'string',
        description: 'Order Status',
        enum: ['placed', 'approved', 'delivered'],
      },
      complete: { type: 'boolean' },
    },
    xml: { name: 'Order' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'placeOrder',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching placeOrder',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '200': {
      response: {
        type: 'object',
        properties: {
          id: { type: 'integer', format: 'int64' },
          petId: { type: 'integer', format: 'int64' },
          quantity: { type: 'integer', format: 'int32' },
          shipDate: { type: 'string', format: 'date-time' },
          status: {
            type: 'string',
            description: 'Order Status',
            enum: ['placed', 'approved', 'delivered'],
          },
          complete: { type: 'boolean' },
        },
        xml: { name: 'Order' },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'placeOrder',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const getUserByName = async ({ params = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/user/{username}\`;

  const paramsSchema = {
    type: 'object',
    required: ['username'],
    properties: { username: { type: 'string' } },
    additionalProperties: false,
  };

  function isParams(obj) {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'getUserByName',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  const paramsKeys = Object.keys(params);

  if (paramsKeys.length) {
    paramsKeys.forEach((param) => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching getUserByName',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '200': {
      response: {
        type: 'object',
        properties: {
          id: { type: 'integer', format: 'int64' },
          username: { type: 'string' },
          firstName: { type: 'string' },
          lastName: { type: 'string' },
          email: { type: 'string' },
          password: { type: 'string' },
          phone: { type: 'string' },
          userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
        },
        xml: { name: 'User' },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'getUserByName',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const updateUser = async (
  { params = {}, data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/user/{username}\`;

  const paramsSchema = {
    type: 'object',
    required: ['username'],
    properties: { username: { type: 'string' } },
    additionalProperties: false,
  };

  function isParams(obj) {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'updateUser',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  const paramsKeys = Object.keys(params);

  if (paramsKeys.length) {
    paramsKeys.forEach((param) => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      username: { type: 'string' },
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      password: { type: 'string' },
      phone: { type: 'string' },
      userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
    },
    xml: { name: 'User' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'updateUser',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
    };
  }

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching updateUser',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'updateUser',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const deleteUser = async ({ params = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/user/{username}\`;

  const paramsSchema = {
    type: 'object',
    required: ['username'],
    properties: { username: { type: 'string' } },
    additionalProperties: false,
  };

  function isParams(obj) {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'deleteUser',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  const paramsKeys = Object.keys(params);

  if (paramsKeys.length) {
    paramsKeys.forEach((param) => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'DELETE',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching deleteUser',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'deleteUser',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const loginUser = async ({ query = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/user/login\`;

  const querySchema = {
    type: 'object',
    required: ['username', 'password'],
    properties: { username: { type: 'string' }, password: { type: 'string' } },
    additionalProperties: false,
  };

  function isQuery(obj) {
    const isValid = ajv.validate(querySchema, obj);

    return !!isValid;
  }

  if (!isQuery(query)) {
    throw new RequestValidationError({
      message: 'Request query string schema validation error',
      method: 'loginUser',
      element: 'query',
      errors: ajv.errors || [],
    });
  }

  if (Object.keys(query)) {
    requestUrl = \`\${requestUrl}?\${stringify(query, { arrayFormat: 'bracket' })}\`;
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching loginUser',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = {
    '200': { response: { type: 'string' }, contentTypes: ['application/json', 'application/xml'] },
    '400': { response: null, contentTypes: null },
  };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'loginUser',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const logoutUser = async (currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/user/logout\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching logoutUser',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = { default: { response: null, contentTypes: null } };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'logoutUser',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const createUser = async ({ data = {} } = {}, currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/user\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      username: { type: 'string' },
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      password: { type: 'string' },
      phone: { type: 'string' },
      userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
    },
    xml: { name: 'User' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'createUser',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching createUser',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = { default: { response: null, contentTypes: null } };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'createUser',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const createUsersWithArrayInput = async (
  { data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/user/createWithArray\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'array',
    items: {
      type: 'object',
      properties: {
        id: { type: 'integer', format: 'int64' },
        username: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        email: { type: 'string' },
        password: { type: 'string' },
        phone: { type: 'string' },
        userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
      },
      xml: { name: 'User' },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'createUsersWithArrayInput',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching createUsersWithArrayInput',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = { default: { response: null, contentTypes: null } };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'createUsersWithArrayInput',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const createUsersWithListInput = async (
  { data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/user/createWithList\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'array',
    items: {
      type: 'object',
      properties: {
        id: { type: 'integer', format: 'int64' },
        username: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        email: { type: 'string' },
        password: { type: 'string' },
        phone: { type: 'string' },
        userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
      },
      xml: { name: 'User' },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'createUsersWithListInput',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
  const responseObject = await fetch(processedUrl, processedParams);

  const responseContentType = responseObject.headers.get('Content-Type');

  let responseJson = null;
  const responseText = await responseObject.text();

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    responseJson = JSON.parse(responseText);
  }

  if (!responseObject.ok) {
    throw new ApiError({
      message: 'Api error while fetching createUsersWithListInput',
      status: responseObject.status,
      statusText: responseObject.statusText,
      response: responseJson,
      headers: responseObject.headers,
    });
  }

  const responseSchema = { default: { response: null, contentTypes: null } };
  const responseStatus = responseObject.status;
  const acceptedContentTypes =
    responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

  if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
    throw new Error('Incorrect content type');
  }

  function isResponse(obj) {
    const isValid =
      !responseSchema[responseStatus] ||
      !responseSchema[responseStatus].response ||
      ajv.validate(responseSchema[responseStatus].response, obj);

    return !!isValid;
  }

  if (
    responseContentType.startsWith('application/json') ||
    responseContentType.startsWith('application/hal+json')
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'createUsersWithListInput',
        errors: ajv.errors || [],
      });
    }
  }

  return {
    json: responseJson,
    text: responseText,
    headers: responseObject.headers,
  };
};
"
`;

exports[`loader should work with ts compiler: runner_result 1`] = `
"import Ajv from 'ajv';
import { stringify } from 'query-string';
import objectToFormData from 'object-to-formdata';

const ajv = new Ajv({ unknownFormats: ['int32', 'int64', 'binary'] });

export class ApiError<T> extends Error {
  status: number;

  statusText: string;

  headers: Headers;

  response: T;

  constructor({
    status,
    statusText,
    response,
    message,
    headers,
  }: {
    status: number;
    statusText: string;
    response: T;
    message: string;
    headers: Headers;
  }) {
    super(message);
    this.status = status;
    this.response = response;
    this.statusText = statusText;
    this.headers = headers;
  }
}

export class ClientCodeError extends Error {}

export class RequestValidationError extends Error {
  element: 'query' | 'params' | 'body' | 'headers';

  method: string;

  errors: Ajv.ErrorObject[];

  constructor({
    message,
    element,
    method,
    errors = [],
  }: {
    message: string;
    element: 'query' | 'params' | 'body' | 'headers';
    method: string;
    errors?: Ajv.ErrorObject[];
  }) {
    super(message);

    this.element = element;
    this.method = method;
    this.errors = errors;
  }
}

export class ResponseValidationError extends Error {
  method: string;

  errors: Ajv.ErrorObject[];

  constructor({
    message,
    method,
    errors = [],
  }: {
    message: string;
    method: string;
    errors?: Ajv.ErrorObject[];
  }) {
    super(message);

    this.method = method;
    this.errors = errors;
  }
}

export interface Config {
  baseUrl: string;
  preMiddleware: (url: string, params: RequestInit) => Promise<[string, RequestInit]>;
}

const defaultConfig: Config = {
  baseUrl: process.env.API_BASE_URL || 'https://petstore.swagger.io/v2',
  preMiddleware: (url: string, params: RequestInit) => Promise.resolve([url, params]),
};

export interface Category {
  id?: number;
  name?: string;
}

export interface Pet {
  id?: number;
  category?: Category;
  name: string;
  photoUrls: string[];
  tags?: Tag[];
  /**
   * pet status in the store
   */
  status?: 'available' | 'pending' | 'sold';
}

export interface Tag {
  id?: number;
  name?: string;
}

export interface ApiResponse {
  code?: number;
  type?: string;
  message?: string;
}

export interface Order {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: string;
  /**
   * Order Status
   */
  status?: 'placed' | 'approved' | 'delivered';
  complete?: boolean;
}

export interface User {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /**
   * User Status
   */
  userStatus?: number;
}

export type OffsetParamParam = number;

export interface AnotherParamParam {
  dateFrom?: string;
  dateTo?: string;
}

export type ErrorRequestBodyJson = User;

export interface ErrorRequestBodyXml {
  id?: string;
  title?: string;
}

const jsToUrlEncoded: (
  element: any,
  key?: string,
  list?: string[]
) => string = function jsToUrlEncoded(element, key = '', list = []) {
  const components = list;

  if (typeof element === 'object') {
    for (let idx in element) {
      jsToUrlEncoded(element[idx], key ? \`\${key}[\${idx}]\` : idx, components);
    }
  } else {
    components.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(element)}\`);
  }

  return components.join('&');
};

export interface OperationResponse<T> {
  json: T | null;
  text: string;
  headers: Headers;
}

export interface SomeOperationRequestBodyXWwwFormUrlencoded {
  /**
   * Name
   */
  name?: string;
  /**
   * meta information
   */
  meta?: {
    title?: string;
    length?: number;
  };
}

export interface SomeOperationResponse200 {
  code?: number;
  type?: string;
  message?: string;
}

export type SomeOperationResponse = SomeOperationResponse200;
export interface GetPetByIdParams {
  petId: number;
}

export interface GetPetByIdResponse200 {
  id?: number;
  category?: {
    id?: number;
    name?: string;
  };
  name: string;
  photoUrls: string[];
  tags?: {
    id?: number;
    name?: string;
  }[];
  /**
   * pet status in the store
   */
  status?: 'available' | 'pending' | 'sold';
}

export type GetPetByIdResponse = GetPetByIdResponse200;
export interface UpdatePetWithFormParams {
  petId: number;
}

export interface UpdatePetWithFormRequestBodyJson {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /**
   * User Status
   */
  userStatus?: number;
}

export interface UpdatePetWithFormRequestBodyXml {
  id?: string;
  title?: string;
}

export type UpdatePetWithFormResponse = unknown;
export interface DeletePetHeaders {
  api_key?: string;
}

export interface DeletePetParams {
  petId: number;
}

export type DeletePetResponse = unknown;
export interface UploadFileParams {
  petId: number;
}

export interface UploadFileRequestBodyFormData {
  /**
   * Additional data to pass to server
   */
  additionalMetadata?: string;
  /**
   * file to upload
   */
  file?: string;
}

export interface UploadFileResponse200 {
  code?: number;
  type?: string;
  message?: string;
}

export type UploadFileResponse = UploadFileResponse200;
export interface UpdatePetRequestBodyJson {
  id?: number;
  category?: {
    id?: number;
    name?: string;
  };
  name: string;
  photoUrls: string[];
  tags?: {
    id?: number;
    name?: string;
  }[];
  /**
   * pet status in the store
   */
  status?: 'available' | 'pending' | 'sold';
}

export interface UpdatePetRequestBodyXml {
  id?: number;
  category?: {
    id?: number;
    name?: string;
  };
  name: string;
  photoUrls: string[];
  tags?: {
    id?: number;
    name?: string;
  }[];
  /**
   * pet status in the store
   */
  status?: 'available' | 'pending' | 'sold';
}

export type UpdatePetResponse = unknown;
export interface AddPetRequestBodyJson {
  id?: number;
  category?: {
    id?: number;
    name?: string;
  };
  name: string;
  photoUrls: string[];
  tags?: {
    id?: number;
    name?: string;
  }[];
  /**
   * pet status in the store
   */
  status?: 'available' | 'pending' | 'sold';
}

export interface AddPetRequestBodyXml {
  id?: number;
  category?: {
    id?: number;
    name?: string;
  };
  name: string;
  photoUrls: string[];
  tags?: {
    id?: number;
    name?: string;
  }[];
  /**
   * pet status in the store
   */
  status?: 'available' | 'pending' | 'sold';
}

export type AddPetResponse = unknown;
export interface FindPetsByStatusQuery {
  status: ('available' | 'pending' | 'sold')[];
}

export type FindPetsByStatusResponse200 = {
  id?: number;
  category?: {
    id?: number;
    name?: string;
  };
  name: string;
  photoUrls: string[];
  tags?: {
    id?: number;
    name?: string;
  }[];
  /**
   * pet status in the store
   */
  status?: 'available' | 'pending' | 'sold';
}[];

export type FindPetsByStatusResponse = FindPetsByStatusResponse200;
export interface FindPetsByTagsQuery {
  tags: string[];
}

export type FindPetsByTagsResponse200 = {
  id?: number;
  category?: {
    id?: number;
    name?: string;
  };
  name: string;
  photoUrls: string[];
  tags?: {
    id?: number;
    name?: string;
  }[];
  /**
   * pet status in the store
   */
  status?: 'available' | 'pending' | 'sold';
}[];

export type FindPetsByTagsResponse = FindPetsByTagsResponse200;
export interface GetInventoryResponse200 {
  [k: string]: number;
}

export type GetInventoryResponse = GetInventoryResponse200;
export interface GetOrderByIdParams {
  orderId: number;
}

export interface GetOrderByIdResponse200 {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: string;
  /**
   * Order Status
   */
  status?: 'placed' | 'approved' | 'delivered';
  complete?: boolean;
}

export type GetOrderByIdResponse = GetOrderByIdResponse200;
export interface DeleteOrderParams {
  orderId: number;
}

export type DeleteOrderResponse = unknown;
export interface PlaceOrderRequestBodyJson {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: string;
  /**
   * Order Status
   */
  status?: 'placed' | 'approved' | 'delivered';
  complete?: boolean;
}

export interface PlaceOrderResponse200 {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: string;
  /**
   * Order Status
   */
  status?: 'placed' | 'approved' | 'delivered';
  complete?: boolean;
}

export type PlaceOrderResponse = PlaceOrderResponse200;
export interface GetUserByNameParams {
  username: string;
}

export interface GetUserByNameResponse200 {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /**
   * User Status
   */
  userStatus?: number;
}

export type GetUserByNameResponse = GetUserByNameResponse200;
export interface UpdateUserParams {
  username: string;
}

export interface UpdateUserRequestBodyJson {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /**
   * User Status
   */
  userStatus?: number;
}

export type UpdateUserResponse = unknown;
export interface DeleteUserParams {
  username: string;
}

export type DeleteUserResponse = unknown;
export interface LoginUserQuery {
  username: string;
  password: string;
}

export type LoginUserResponse200 = string;

export type LoginUserResponse = LoginUserResponse200;

export type LogoutUserResponse = unknown;
export interface CreateUserRequestBodyJson {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /**
   * User Status
   */
  userStatus?: number;
}

export type CreateUserResponse = unknown;
export type CreateUsersWithArrayInputRequestBodyJson = {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /**
   * User Status
   */
  userStatus?: number;
}[];

export type CreateUsersWithArrayInputResponse = unknown;
export type CreateUsersWithListInputRequestBodyJson = {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
  /**
   * User Status
   */
  userStatus?: number;
}[];

export type CreateUsersWithListInputResponse = unknown;
export interface SomeOperationRequest {
  data?: FormData | SomeOperationRequestBodyXWwwFormUrlencoded;
}
export const someOperation: (
  request: SomeOperationRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<SomeOperationResponse>> = async (
  { data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/pet/someOperation\`;

  const requestHeaders = {
    'Content-Type': 'application/x-www-form-urlencoded',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      name: { type: 'string', description: 'Name' },
      meta: {
        type: 'object',
        description: 'meta information',
        properties: { title: { type: 'string' }, length: { type: 'number' } },
      },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'someOperation',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = jsToUrlEncoded(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '200': {
      response: {
        type: 'object',
        properties: {
          code: { type: 'integer', format: 'int32' },
          type: { type: 'string' },
          message: { type: 'string' },
        },
      },
      contentTypes: ['application/json'],
    },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching someOperation',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is SomeOperationResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'someOperation',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface GetPetByIdRequest {
  params?: GetPetByIdParams;
}
export const getPetById: (
  request: GetPetByIdRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<GetPetByIdResponse>> = async (
  { params = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/{petId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj: unknown): obj is GetPetByIdParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'getPetById',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  type GetPetByIdParamsKeys = keyof GetPetByIdParams;

  const paramsKeys = Object.keys(params) as GetPetByIdParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '200': {
      response: {
        required: ['name', 'photoUrls'],
        type: 'object',
        properties: {
          id: { type: 'integer', format: 'int64' },
          category: {
            type: 'object',
            properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
            xml: { name: 'Category' },
          },
          name: { type: 'string', example: 'doggie' },
          photoUrls: {
            type: 'array',
            xml: { wrapped: true },
            items: { type: 'string', xml: { name: 'photoUrl' } },
          },
          tags: {
            type: 'array',
            xml: { wrapped: true },
            items: {
              type: 'object',
              properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
              xml: { name: 'Tag' },
            },
          },
          status: {
            type: 'string',
            description: 'pet status in the store',
            enum: ['available', 'pending', 'sold'],
          },
        },
        xml: { name: 'Pet' },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching getPetById',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is GetPetByIdResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'getPetById',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface UpdatePetWithFormRequest {
  params?: UpdatePetWithFormParams;
  data?: FormData | UpdatePetWithFormRequestBodyJson;
}
export const updatePetWithForm: (
  request: UpdatePetWithFormRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<UpdatePetWithFormResponse>> = async (
  { params = {}, data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/{petId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj: unknown): obj is UpdatePetWithFormParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'updatePetWithForm',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  type UpdatePetWithFormParamsKeys = keyof UpdatePetWithFormParams;

  const paramsKeys = Object.keys(params) as UpdatePetWithFormParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      username: { type: 'string' },
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      password: { type: 'string' },
      phone: { type: 'string' },
      userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
    },
    xml: { name: 'User' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'updatePetWithForm',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = { '405': { response: null, contentTypes: null } };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching updatePetWithForm',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is UpdatePetWithFormResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'updatePetWithForm',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface DeletePetRequest {
  params?: DeletePetParams;
  headers?: DeletePetHeaders;
}
export const deletePet: (
  request: DeletePetRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<DeletePetResponse>> = async (
  { params = {}, headers = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/{petId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj: unknown): obj is DeletePetParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'deletePet',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  type DeletePetParamsKeys = keyof DeletePetParams;

  const paramsKeys = Object.keys(params) as DeletePetParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const headersSchema = {
    type: 'object',
    required: [],
    properties: { api_key: { type: 'string' } },
    additionalProperties: false,
  };

  function isHeaders(obj: unknown): obj is DeletePetHeaders {
    const isValid = ajv.validate(headersSchema, obj);

    return !!isValid;
  }

  if (!isHeaders(headers)) {
    throw new RequestValidationError({
      message: 'Request headers schema validation error',
      method: 'deletePet',
      element: 'headers',
      errors: ajv.errors || [],
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
    ...headers,
  };

  const requestParams = {
    method: 'DELETE',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(
      requestUrl,
      requestParams as RequestInit
    );
    responseObject = await fetch(processedUrl, processedParams as RequestInit);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching deletePet',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is DeletePetResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'deletePet',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface UploadFileRequest {
  params?: UploadFileParams;
  data?: FormData | UploadFileRequestBodyFormData;
}
export const uploadFile: (
  request: UploadFileRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<UploadFileResponse>> = async (
  { params = {}, data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/{petId}/uploadImage\`;

  const paramsSchema = {
    type: 'object',
    required: ['petId'],
    properties: { petId: { type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj: unknown): obj is UploadFileParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'uploadFile',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  type UploadFileParamsKeys = keyof UploadFileParams;

  const paramsKeys = Object.keys(params) as UploadFileParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'multipart/form-data',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      additionalMetadata: { type: 'string', description: 'Additional data to pass to server' },
      file: { type: 'object', description: 'file to upload', format: 'binary' },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'uploadFile',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = objectToFormData(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '200': {
      response: {
        type: 'object',
        properties: {
          code: { type: 'integer', format: 'int32' },
          type: { type: 'string' },
          message: { type: 'string' },
        },
      },
      contentTypes: ['application/json'],
    },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching uploadFile',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is UploadFileResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'uploadFile',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface UpdatePetRequest {
  data?: FormData | UpdatePetRequestBodyJson;
}
export const updatePet: (
  request: UpdatePetRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<UpdatePetResponse>> = async (
  { data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/pet\`;

  const requestHeaders = {
    'Content-Type': 'application/json; charset=utf-8',
  };

  const bodySchema = {
    required: ['name', 'photoUrls'],
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      category: {
        type: 'object',
        properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
        xml: { name: 'Category' },
      },
      name: { type: 'string', example: 'doggie' },
      photoUrls: {
        type: 'array',
        xml: { wrapped: true },
        items: { type: 'string', xml: { name: 'photoUrl' } },
      },
      tags: {
        type: 'array',
        xml: { wrapped: true },
        items: {
          type: 'object',
          properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
          xml: { name: 'Tag' },
        },
      },
      status: {
        type: 'string',
        description: 'pet status in the store',
        enum: ['available', 'pending', 'sold'],
      },
    },
    xml: { name: 'Pet' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'updatePet',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
    };
  }

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
    '405': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching updatePet',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is UpdatePetResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'updatePet',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface AddPetRequest {
  data?: FormData | AddPetRequestBodyJson;
}
export const addPet: (
  request: AddPetRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<AddPetResponse>> = async (
  { data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/pet\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    required: ['name', 'photoUrls'],
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      category: {
        type: 'object',
        properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
        xml: { name: 'Category' },
      },
      name: { type: 'string', example: 'doggie' },
      photoUrls: {
        type: 'array',
        xml: { wrapped: true },
        items: { type: 'string', xml: { name: 'photoUrl' } },
      },
      tags: {
        type: 'array',
        xml: { wrapped: true },
        items: {
          type: 'object',
          properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
          xml: { name: 'Tag' },
        },
      },
      status: {
        type: 'string',
        description: 'pet status in the store',
        enum: ['available', 'pending', 'sold'],
      },
    },
    xml: { name: 'Pet' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'addPet',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = { '405': { response: null, contentTypes: null } };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching addPet',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is AddPetResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'addPet',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface FindPetsByStatusRequest {
  query?: FindPetsByStatusQuery;
}
export const findPetsByStatus: (
  request: FindPetsByStatusRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<FindPetsByStatusResponse>> = async (
  { query = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/findByStatus\`;

  const querySchema = {
    type: 'object',
    required: ['status'],
    properties: {
      status: {
        type: 'array',
        items: { type: 'string', default: 'available', enum: ['available', 'pending', 'sold'] },
      },
    },
    additionalProperties: false,
  };

  function isQuery(obj: unknown): obj is FindPetsByStatusQuery {
    const isValid = ajv.validate(querySchema, obj);

    return !!isValid;
  }

  if (!isQuery(query)) {
    throw new RequestValidationError({
      message: 'Request query string schema validation error',
      method: 'findPetsByStatus',
      element: 'query',
      errors: ajv.errors || [],
    });
  }

  if (Object.keys(query)) {
    requestUrl = \`\${requestUrl}?\${stringify(query, { arrayFormat: 'bracket' })}\`;
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '200': {
      response: {
        type: 'array',
        items: {
          required: ['name', 'photoUrls'],
          type: 'object',
          properties: {
            id: { type: 'integer', format: 'int64' },
            category: {
              type: 'object',
              properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
              xml: { name: 'Category' },
            },
            name: { type: 'string', example: 'doggie' },
            photoUrls: {
              type: 'array',
              xml: { wrapped: true },
              items: { type: 'string', xml: { name: 'photoUrl' } },
            },
            tags: {
              type: 'array',
              xml: { wrapped: true },
              items: {
                type: 'object',
                properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
                xml: { name: 'Tag' },
              },
            },
            status: {
              type: 'string',
              description: 'pet status in the store',
              enum: ['available', 'pending', 'sold'],
            },
          },
          xml: { name: 'Pet' },
        },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching findPetsByStatus',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is FindPetsByStatusResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'findPetsByStatus',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface FindPetsByTagsRequest {
  query?: FindPetsByTagsQuery;
}
export const findPetsByTags: (
  request: FindPetsByTagsRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<FindPetsByTagsResponse>> = async (
  { query = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/pet/findByTags\`;

  const querySchema = {
    type: 'object',
    required: ['tags'],
    properties: { tags: { type: 'array', items: { type: 'string' } } },
    additionalProperties: false,
  };

  function isQuery(obj: unknown): obj is FindPetsByTagsQuery {
    const isValid = ajv.validate(querySchema, obj);

    return !!isValid;
  }

  if (!isQuery(query)) {
    throw new RequestValidationError({
      message: 'Request query string schema validation error',
      method: 'findPetsByTags',
      element: 'query',
      errors: ajv.errors || [],
    });
  }

  if (Object.keys(query)) {
    requestUrl = \`\${requestUrl}?\${stringify(query, { arrayFormat: 'bracket' })}\`;
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '200': {
      response: {
        type: 'array',
        items: {
          required: ['name', 'photoUrls'],
          type: 'object',
          properties: {
            id: { type: 'integer', format: 'int64' },
            category: {
              type: 'object',
              properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
              xml: { name: 'Category' },
            },
            name: { type: 'string', example: 'doggie' },
            photoUrls: {
              type: 'array',
              xml: { wrapped: true },
              items: { type: 'string', xml: { name: 'photoUrl' } },
            },
            tags: {
              type: 'array',
              xml: { wrapped: true },
              items: {
                type: 'object',
                properties: { id: { type: 'integer', format: 'int64' }, name: { type: 'string' } },
                xml: { name: 'Tag' },
              },
            },
            status: {
              type: 'string',
              description: 'pet status in the store',
              enum: ['available', 'pending', 'sold'],
            },
          },
          xml: { name: 'Pet' },
        },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching findPetsByTags',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is FindPetsByTagsResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'findPetsByTags',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const getInventory: (
  config?: Partial<Config>
) => Promise<OperationResponse<GetInventoryResponse>> = async (currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/store/inventory\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '200': {
      response: { type: 'object', additionalProperties: { type: 'integer', format: 'int32' } },
      contentTypes: ['application/json'],
    },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching getInventory',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is GetInventoryResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'getInventory',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface GetOrderByIdRequest {
  params?: GetOrderByIdParams;
}
export const getOrderById: (
  request: GetOrderByIdRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<GetOrderByIdResponse>> = async (
  { params = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/store/order/{orderId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['orderId'],
    properties: { orderId: { maximum: 10, minimum: 1, type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj: unknown): obj is GetOrderByIdParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'getOrderById',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  type GetOrderByIdParamsKeys = keyof GetOrderByIdParams;

  const paramsKeys = Object.keys(params) as GetOrderByIdParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '200': {
      response: {
        type: 'object',
        properties: {
          id: { type: 'integer', format: 'int64' },
          petId: { type: 'integer', format: 'int64' },
          quantity: { type: 'integer', format: 'int32' },
          shipDate: { type: 'string', format: 'date-time' },
          status: {
            type: 'string',
            description: 'Order Status',
            enum: ['placed', 'approved', 'delivered'],
          },
          complete: { type: 'boolean' },
        },
        xml: { name: 'Order' },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching getOrderById',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is GetOrderByIdResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'getOrderById',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface DeleteOrderRequest {
  params?: DeleteOrderParams;
}
export const deleteOrder: (
  request: DeleteOrderRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<DeleteOrderResponse>> = async (
  { params = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/store/order/{orderId}\`;

  const paramsSchema = {
    type: 'object',
    required: ['orderId'],
    properties: { orderId: { minimum: 1, type: 'integer', format: 'int64' } },
    additionalProperties: false,
  };

  function isParams(obj: unknown): obj is DeleteOrderParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'deleteOrder',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  type DeleteOrderParamsKeys = keyof DeleteOrderParams;

  const paramsKeys = Object.keys(params) as DeleteOrderParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'DELETE',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching deleteOrder',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is DeleteOrderResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'deleteOrder',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface PlaceOrderRequest {
  data?: FormData | PlaceOrderRequestBodyJson;
}
export const placeOrder: (
  request: PlaceOrderRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<PlaceOrderResponse>> = async (
  { data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/store/order\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      petId: { type: 'integer', format: 'int64' },
      quantity: { type: 'integer', format: 'int32' },
      shipDate: { type: 'string', format: 'date-time' },
      status: {
        type: 'string',
        description: 'Order Status',
        enum: ['placed', 'approved', 'delivered'],
      },
      complete: { type: 'boolean' },
    },
    xml: { name: 'Order' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'placeOrder',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '200': {
      response: {
        type: 'object',
        properties: {
          id: { type: 'integer', format: 'int64' },
          petId: { type: 'integer', format: 'int64' },
          quantity: { type: 'integer', format: 'int32' },
          shipDate: { type: 'string', format: 'date-time' },
          status: {
            type: 'string',
            description: 'Order Status',
            enum: ['placed', 'approved', 'delivered'],
          },
          complete: { type: 'boolean' },
        },
        xml: { name: 'Order' },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching placeOrder',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is PlaceOrderResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'placeOrder',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface GetUserByNameRequest {
  params?: GetUserByNameParams;
}
export const getUserByName: (
  request: GetUserByNameRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<GetUserByNameResponse>> = async (
  { params = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/user/{username}\`;

  const paramsSchema = {
    type: 'object',
    required: ['username'],
    properties: { username: { type: 'string' } },
    additionalProperties: false,
  };

  function isParams(obj: unknown): obj is GetUserByNameParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'getUserByName',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  type GetUserByNameParamsKeys = keyof GetUserByNameParams;

  const paramsKeys = Object.keys(params) as GetUserByNameParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '200': {
      response: {
        type: 'object',
        properties: {
          id: { type: 'integer', format: 'int64' },
          username: { type: 'string' },
          firstName: { type: 'string' },
          lastName: { type: 'string' },
          email: { type: 'string' },
          password: { type: 'string' },
          phone: { type: 'string' },
          userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
        },
        xml: { name: 'User' },
      },
      contentTypes: ['application/json', 'application/xml'],
    },
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching getUserByName',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is GetUserByNameResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'getUserByName',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface UpdateUserRequest {
  params?: UpdateUserParams;
  data?: FormData | UpdateUserRequestBodyJson;
}
export const updateUser: (
  request: UpdateUserRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<UpdateUserResponse>> = async (
  { params = {}, data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/user/{username}\`;

  const paramsSchema = {
    type: 'object',
    required: ['username'],
    properties: { username: { type: 'string' } },
    additionalProperties: false,
  };

  function isParams(obj: unknown): obj is UpdateUserParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'updateUser',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  type UpdateUserParamsKeys = keyof UpdateUserParams;

  const paramsKeys = Object.keys(params) as UpdateUserParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      username: { type: 'string' },
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      password: { type: 'string' },
      phone: { type: 'string' },
      userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
    },
    xml: { name: 'User' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'updateUser',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'PUT',
      headers: requestHeaders,
    };
  }

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching updateUser',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is UpdateUserResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'updateUser',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface DeleteUserRequest {
  params?: DeleteUserParams;
}
export const deleteUser: (
  request: DeleteUserRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<DeleteUserResponse>> = async (
  { params = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/user/{username}\`;

  const paramsSchema = {
    type: 'object',
    required: ['username'],
    properties: { username: { type: 'string' } },
    additionalProperties: false,
  };

  function isParams(obj: unknown): obj is DeleteUserParams {
    const isValid = ajv.validate(paramsSchema, obj);

    return !!isValid;
  }

  if (!isParams(params)) {
    throw new RequestValidationError({
      message: 'Request params schema validation error',
      method: 'deleteUser',
      element: 'params',
      errors: ajv.errors || [],
    });
  }

  type DeleteUserParamsKeys = keyof DeleteUserParams;

  const paramsKeys = Object.keys(params) as DeleteUserParamsKeys[];

  if (paramsKeys.length) {
    paramsKeys.forEach(param => {
      requestUrl = requestUrl.replace(\`{\${param}}\`, encodeURIComponent(String(params[param])));
    });
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'DELETE',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '400': { response: null, contentTypes: null },
    '404': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching deleteUser',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is DeleteUserResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'deleteUser',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface LoginUserRequest {
  query?: LoginUserQuery;
}
export const loginUser: (
  request: LoginUserRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<LoginUserResponse>> = async (
  { query = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  let requestUrl = \`\${config.baseUrl}/user/login\`;

  const querySchema = {
    type: 'object',
    required: ['username', 'password'],
    properties: { username: { type: 'string' }, password: { type: 'string' } },
    additionalProperties: false,
  };

  function isQuery(obj: unknown): obj is LoginUserQuery {
    const isValid = ajv.validate(querySchema, obj);

    return !!isValid;
  }

  if (!isQuery(query)) {
    throw new RequestValidationError({
      message: 'Request query string schema validation error',
      method: 'loginUser',
      element: 'query',
      errors: ajv.errors || [],
    });
  }

  if (Object.keys(query)) {
    requestUrl = \`\${requestUrl}?\${stringify(query, { arrayFormat: 'bracket' })}\`;
  }

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = {
    '200': { response: { type: 'string' }, contentTypes: ['application/json', 'application/xml'] },
    '400': { response: null, contentTypes: null },
  };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching loginUser',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is LoginUserResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'loginUser',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export const logoutUser: (
  config?: Partial<Config>
) => Promise<OperationResponse<LogoutUserResponse>> = async (currentConfig = defaultConfig) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/user/logout\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const requestParams = {
    method: 'GET',
    headers: requestHeaders,
  };

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = { default: { response: null, contentTypes: null } };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching logoutUser',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is LogoutUserResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'logoutUser',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface CreateUserRequest {
  data?: FormData | CreateUserRequestBodyJson;
}
export const createUser: (
  request: CreateUserRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<CreateUserResponse>> = async (
  { data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/user\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'object',
    properties: {
      id: { type: 'integer', format: 'int64' },
      username: { type: 'string' },
      firstName: { type: 'string' },
      lastName: { type: 'string' },
      email: { type: 'string' },
      password: { type: 'string' },
      phone: { type: 'string' },
      userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
    },
    xml: { name: 'User' },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'createUser',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = { default: { response: null, contentTypes: null } };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching createUser',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is CreateUserResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'createUser',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface CreateUsersWithArrayInputRequest {
  data?: FormData | CreateUsersWithArrayInputRequestBodyJson;
}
export const createUsersWithArrayInput: (
  request: CreateUsersWithArrayInputRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<CreateUsersWithArrayInputResponse>> = async (
  { data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/user/createWithArray\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'array',
    items: {
      type: 'object',
      properties: {
        id: { type: 'integer', format: 'int64' },
        username: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        email: { type: 'string' },
        password: { type: 'string' },
        phone: { type: 'string' },
        userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
      },
      xml: { name: 'User' },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'createUsersWithArrayInput',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = { default: { response: null, contentTypes: null } };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching createUsersWithArrayInput',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is CreateUsersWithArrayInputResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'createUsersWithArrayInput',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
export interface CreateUsersWithListInputRequest {
  data?: FormData | CreateUsersWithListInputRequestBodyJson;
}
export const createUsersWithListInput: (
  request: CreateUsersWithListInputRequest,
  config?: Partial<Config>
) => Promise<OperationResponse<CreateUsersWithListInputResponse>> = async (
  { data = {} } = {},
  currentConfig = defaultConfig
) => {
  const config = { ...defaultConfig, ...currentConfig };

  const requestUrl = \`\${config.baseUrl}/user/createWithList\`;

  const requestHeaders = {
    'Content-Type': 'application/json',
  };

  const bodySchema = {
    type: 'array',
    items: {
      type: 'object',
      properties: {
        id: { type: 'integer', format: 'int64' },
        username: { type: 'string' },
        firstName: { type: 'string' },
        lastName: { type: 'string' },
        email: { type: 'string' },
        password: { type: 'string' },
        phone: { type: 'string' },
        userStatus: { type: 'integer', description: 'User Status', format: 'int32' },
      },
      xml: { name: 'User' },
    },
  };
  const isBodyValid = ajv.validate(bodySchema, data);

  if (!isBodyValid) {
    throw new RequestValidationError({
      message: 'Request body schema validation error',
      method: 'createUsersWithListInput',
      element: 'body',
      errors: ajv.errors || [],
    });
  }

  let requestParams;
  let body = null;

  if (data && typeof data === 'object') {
    body = JSON.stringify(data);
  }

  if (body) {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
      body,
    };
  } else {
    requestParams = {
      method: 'POST',
      headers: requestHeaders,
    };
  }

  const responseSchema: {
    [key: string]: { response: string | boolean | object | null; contentTypes: string[] | null };
  } = { default: { response: null, contentTypes: null } };
  let responseStatus: number;
  let acceptedContentTypes: string[] | null;
  let responseJson: unknown;
  let responseText: string;
  let responseObject: Response;
  let responseContentType: string;

  try {
    const [processedUrl, processedParams] = await config.preMiddleware(requestUrl, requestParams);
    responseObject = await fetch(processedUrl, processedParams);
    responseContentType = responseObject.headers.get('Content-Type') || 'application/json';

    responseText = await responseObject.text();

    if (
      responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')
    ) {
      responseJson = JSON.parse(responseText);
    }

    if (!responseObject.ok) {
      throw new ApiError<typeof responseJson>({
        message: 'Api error while fetching createUsersWithListInput',
        status: responseObject.status,
        statusText: responseObject.statusText,
        response: responseJson,
        headers: responseObject.headers,
      });
    }
    responseStatus = responseObject.status;
    acceptedContentTypes =
      responseSchema[responseStatus] && responseSchema[responseStatus].contentTypes;

    if (acceptedContentTypes && !acceptedContentTypes.includes(responseContentType)) {
      throw new Error('Incorrect content type');
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    } else {
      throw error as ClientCodeError;
    }
  }

  function isResponse(obj: unknown): obj is CreateUsersWithListInputResponse {
    const isValid = ajv.validate(
      responseSchema[responseStatus.toString()].response as string | boolean | object,
      obj
    );

    return !!isValid;
  }

  if (
    (responseContentType.startsWith('application/json') ||
      responseContentType.startsWith('application/hal+json')) &&
    responseSchema &&
    responseSchema[responseStatus.toString()] &&
    responseSchema[responseStatus.toString()].response
  ) {
    if (!isResponse(responseJson)) {
      throw new ResponseValidationError({
        message: 'Response schema validation error',
        method: 'createUsersWithListInput',
        errors: ajv.errors || [],
      });
    }

    return {
      json: responseJson,
      text: responseText,
      headers: responseObject.headers,
    };
  }

  return {
    json: null,
    text: responseText,
    headers: responseObject.headers,
  };
};
"
`;

exports[`loader should work with ts-loader: errors 1`] = `Array []`;

exports[`loader should work with ts-loader: result 1`] = `undefined`;

exports[`loader should work with ts-loader: warnings 1`] = `Array []`;
